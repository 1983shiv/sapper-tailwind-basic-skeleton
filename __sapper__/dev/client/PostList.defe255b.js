import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, e as element, b as space, c as create_component, t as text, a as svg_element, f as claim_element, g as children, h as detach_dev, j as claim_space, l as claim_component, k as claim_text, m as attr_dev, n as add_location, o as insert_dev, p as append_dev, q as mount_component, M as set_data_dev, u as transition_in, w as transition_out, x as destroy_component, K as validate_each_argument, J as empty, E as group_outros, F as check_outros, L as destroy_each } from './client.66758637.js';
import { T as Tags, s as slugify } from './Tags.a974cee7.js';

/* src\components\PostCard.svelte generated by Svelte v3.38.2 */
const file = "src\\components\\PostCard.svelte";

function create_fragment$1(ctx) {
	let div3;
	let div2;
	let a0;
	let img;
	let img_src_value;
	let img_alt_value;
	let a0_href_value;
	let t0;
	let div1;
	let h2;
	let tags;
	let t1;
	let h1;
	let t2_value = /*post*/ ctx[0].title + "";
	let t2;
	let t3;
	let p;
	let t4_value = (/*post*/ ctx[0].summery ? /*post*/ ctx[0].summery : "") + "";
	let t4;
	let t5;
	let div0;
	let a1;
	let t6;
	let svg0;
	let path0;
	let path1;
	let a1_href_value;
	let t7;
	let span0;
	let svg1;
	let path2;
	let circle;
	let t8;
	let t9;
	let span1;
	let svg2;
	let path3;
	let t10;
	let current;

	tags = new Tags({
			props: { tags: /*post*/ ctx[0].tags },
			$$inline: true
		});

	const block = {
		c: function create() {
			div3 = element("div");
			div2 = element("div");
			a0 = element("a");
			img = element("img");
			t0 = space();
			div1 = element("div");
			h2 = element("h2");
			create_component(tags.$$.fragment);
			t1 = space();
			h1 = element("h1");
			t2 = text(t2_value);
			t3 = space();
			p = element("p");
			t4 = text(t4_value);
			t5 = space();
			div0 = element("div");
			a1 = element("a");
			t6 = text("Learn More\r\n          ");
			svg0 = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			t7 = space();
			span0 = element("span");
			svg1 = svg_element("svg");
			path2 = svg_element("path");
			circle = svg_element("circle");
			t8 = text("1.2K");
			t9 = space();
			span1 = element("span");
			svg2 = svg_element("svg");
			path3 = svg_element("path");
			t10 = text("6");
			this.h();
		},
		l: function claim(nodes) {
			div3 = claim_element(nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			a0 = claim_element(div2_nodes, "A", { href: true });
			var a0_nodes = children(a0);
			img = claim_element(a0_nodes, "IMG", { class: true, src: true, alt: true });
			a0_nodes.forEach(detach_dev);
			t0 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			h2 = claim_element(div1_nodes, "H2", { class: true });
			var h2_nodes = children(h2);
			claim_component(tags.$$.fragment, h2_nodes);
			h2_nodes.forEach(detach_dev);
			t1 = claim_space(div1_nodes);
			h1 = claim_element(div1_nodes, "H1", { class: true });
			var h1_nodes = children(h1);
			t2 = claim_text(h1_nodes, t2_value);
			h1_nodes.forEach(detach_dev);
			t3 = claim_space(div1_nodes);
			p = claim_element(div1_nodes, "P", { class: true });
			var p_nodes = children(p);
			t4 = claim_text(p_nodes, t4_value);
			p_nodes.forEach(detach_dev);
			t5 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			a1 = claim_element(div0_nodes, "A", { href: true, class: true });
			var a1_nodes = children(a1);
			t6 = claim_text(a1_nodes, "Learn More\r\n          ");

			svg0 = claim_element(
				a1_nodes,
				"svg",
				{
					class: true,
					viewBox: true,
					stroke: true,
					"stroke-width": true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true
				},
				1
			);

			var svg0_nodes = children(svg0);
			path0 = claim_element(svg0_nodes, "path", { d: true }, 1);
			children(path0).forEach(detach_dev);
			path1 = claim_element(svg0_nodes, "path", { d: true }, 1);
			children(path1).forEach(detach_dev);
			svg0_nodes.forEach(detach_dev);
			a1_nodes.forEach(detach_dev);
			t7 = claim_space(div0_nodes);
			span0 = claim_element(div0_nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);

			svg1 = claim_element(
				span0_nodes,
				"svg",
				{
					class: true,
					stroke: true,
					"stroke-width": true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true,
					viewBox: true
				},
				1
			);

			var svg1_nodes = children(svg1);
			path2 = claim_element(svg1_nodes, "path", { d: true }, 1);
			children(path2).forEach(detach_dev);
			circle = claim_element(svg1_nodes, "circle", { cx: true, cy: true, r: true }, 1);
			children(circle).forEach(detach_dev);
			svg1_nodes.forEach(detach_dev);
			t8 = claim_text(span0_nodes, "1.2K");
			span0_nodes.forEach(detach_dev);
			t9 = claim_space(div0_nodes);
			span1 = claim_element(div0_nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);

			svg2 = claim_element(
				span1_nodes,
				"svg",
				{
					class: true,
					stroke: true,
					"stroke-width": true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true,
					viewBox: true
				},
				1
			);

			var svg2_nodes = children(svg2);
			path3 = claim_element(svg2_nodes, "path", { d: true }, 1);
			children(path3).forEach(detach_dev);
			svg2_nodes.forEach(detach_dev);
			t10 = claim_text(span1_nodes, "6");
			span1_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(img, "class", "w-full object-cover object-center");
			if (img.src !== (img_src_value = /*post*/ ctx[0].image)) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", img_alt_value = /*post*/ ctx[0].title);
			add_location(img, file, 11, 6, 325);
			attr_dev(a0, "href", a0_href_value = `/posts/${slugify(/*post*/ ctx[0].title)}`);
			add_location(a0, file, 10, 4, 275);
			attr_dev(h2, "class", "tracking-widest text-xs title-font font-medium text-gray-400 mb-1");
			add_location(h2, file, 18, 6, 483);
			attr_dev(h1, "class", "title-font text-lg font-medium text-gray-900 mb-3");
			add_location(h1, file, 23, 6, 634);
			attr_dev(p, "class", "leading-relaxed mb-3");
			add_location(p, file, 26, 6, 739);
			attr_dev(path0, "d", "M5 12h14");
			add_location(path0, file, 43, 12, 1309);
			attr_dev(path1, "d", "M12 5l7 7-7 7");
			add_location(path1, file, 44, 12, 1344);
			attr_dev(svg0, "class", "w-4 h-4 ml-2");
			attr_dev(svg0, "viewBox", "0 0 24 24");
			attr_dev(svg0, "stroke", "currentColor");
			attr_dev(svg0, "stroke-width", "2");
			attr_dev(svg0, "fill", "none");
			attr_dev(svg0, "stroke-linecap", "round");
			attr_dev(svg0, "stroke-linejoin", "round");
			add_location(svg0, file, 34, 10, 1048);
			attr_dev(a1, "href", a1_href_value = `/posts/${slugify(/*post*/ ctx[0].title)}`);
			attr_dev(a1, "class", "text-pink-500 inline-flex items-center md:mb-2 lg:mb-0");
			add_location(a1, file, 30, 8, 887);
			attr_dev(path2, "d", "M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z");
			add_location(path2, file, 59, 12, 1849);
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "3");
			add_location(circle, file, 60, 12, 1920);
			attr_dev(svg1, "class", "w-4 h-4 mr-1");
			attr_dev(svg1, "stroke", "currentColor");
			attr_dev(svg1, "stroke-width", "2");
			attr_dev(svg1, "fill", "none");
			attr_dev(svg1, "stroke-linecap", "round");
			attr_dev(svg1, "stroke-linejoin", "round");
			attr_dev(svg1, "viewBox", "0 0 24 24");
			add_location(svg1, file, 50, 10, 1588);
			attr_dev(span0, "class", "text-gray-400 mr-3 inline-flex items-center lg:ml-auto md:ml-0 ml-auto leading-none text-sm pr-3 py-1 border-r-2 border-gray-200");
			add_location(span0, file, 47, 8, 1412);
			attr_dev(path3, "d", "M21 11.5a8.38 8.38 0 01-.9 3.8 8.5 8.5 0 01-7.6 4.7 8.38 8.38 0 01-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 01-.9-3.8 8.5 8.5 0 014.7-7.6 8.38 8.38 0 013.8-.9h.5a8.48 8.48 0 018 8v.5z");
			add_location(path3, file, 75, 12, 2369);
			attr_dev(svg2, "class", "w-4 h-4 mr-1");
			attr_dev(svg2, "stroke", "currentColor");
			attr_dev(svg2, "stroke-width", "2");
			attr_dev(svg2, "fill", "none");
			attr_dev(svg2, "stroke-linecap", "round");
			attr_dev(svg2, "stroke-linejoin", "round");
			attr_dev(svg2, "viewBox", "0 0 24 24");
			add_location(svg2, file, 66, 10, 2108);
			attr_dev(span1, "class", "text-gray-400 inline-flex items-center leading-none text-sm");
			add_location(span1, file, 63, 8, 2001);
			attr_dev(div0, "class", "flex items-center flex-wrap ");
			add_location(div0, file, 29, 6, 835);
			attr_dev(div1, "class", "p-6");
			add_location(div1, file, 17, 4, 458);
			attr_dev(div2, "class", "w-200 h-auto border-2 border-gray-200 border-opacity-60 rounded-lg overflow-hidden");
			add_location(div2, file, 7, 2, 164);
			attr_dev(div3, "class", "p-4 md:w-1/3");
			add_location(div3, file, 6, 0, 134);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, div2);
			append_dev(div2, a0);
			append_dev(a0, img);
			append_dev(div2, t0);
			append_dev(div2, div1);
			append_dev(div1, h2);
			mount_component(tags, h2, null);
			append_dev(div1, t1);
			append_dev(div1, h1);
			append_dev(h1, t2);
			append_dev(div1, t3);
			append_dev(div1, p);
			append_dev(p, t4);
			append_dev(div1, t5);
			append_dev(div1, div0);
			append_dev(div0, a1);
			append_dev(a1, t6);
			append_dev(a1, svg0);
			append_dev(svg0, path0);
			append_dev(svg0, path1);
			append_dev(div0, t7);
			append_dev(div0, span0);
			append_dev(span0, svg1);
			append_dev(svg1, path2);
			append_dev(svg1, circle);
			append_dev(span0, t8);
			append_dev(div0, t9);
			append_dev(div0, span1);
			append_dev(span1, svg2);
			append_dev(svg2, path3);
			append_dev(span1, t10);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (!current || dirty & /*post*/ 1 && img.src !== (img_src_value = /*post*/ ctx[0].image)) {
				attr_dev(img, "src", img_src_value);
			}

			if (!current || dirty & /*post*/ 1 && img_alt_value !== (img_alt_value = /*post*/ ctx[0].title)) {
				attr_dev(img, "alt", img_alt_value);
			}

			if (!current || dirty & /*post*/ 1 && a0_href_value !== (a0_href_value = `/posts/${slugify(/*post*/ ctx[0].title)}`)) {
				attr_dev(a0, "href", a0_href_value);
			}

			const tags_changes = {};
			if (dirty & /*post*/ 1) tags_changes.tags = /*post*/ ctx[0].tags;
			tags.$set(tags_changes);
			if ((!current || dirty & /*post*/ 1) && t2_value !== (t2_value = /*post*/ ctx[0].title + "")) set_data_dev(t2, t2_value);
			if ((!current || dirty & /*post*/ 1) && t4_value !== (t4_value = (/*post*/ ctx[0].summery ? /*post*/ ctx[0].summery : "") + "")) set_data_dev(t4, t4_value);

			if (!current || dirty & /*post*/ 1 && a1_href_value !== (a1_href_value = `/posts/${slugify(/*post*/ ctx[0].title)}`)) {
				attr_dev(a1, "href", a1_href_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(tags.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(tags.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
			destroy_component(tags);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("PostCard", slots, []);
	let { post } = $$props;
	const writable_props = ["post"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<PostCard> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("post" in $$props) $$invalidate(0, post = $$props.post);
	};

	$$self.$capture_state = () => ({ slugify, Tags, post });

	$$self.$inject_state = $$props => {
		if ("post" in $$props) $$invalidate(0, post = $$props.post);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [post];
}

class PostCard extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { post: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "PostCard",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*post*/ ctx[0] === undefined && !("post" in props)) {
			console.warn("<PostCard> was created without expected prop 'post'");
		}
	}

	get post() {
		throw new Error("<PostCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set post(value) {
		throw new Error("<PostCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\PostList.svelte generated by Svelte v3.38.2 */

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[1] = list[i];
	return child_ctx;
}

// (6:0) {#each posts as post}
function create_each_block(ctx) {
	let postcard;
	let current;

	postcard = new PostCard({
			props: { post: /*post*/ ctx[1] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(postcard.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(postcard.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(postcard, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const postcard_changes = {};
			if (dirty & /*posts*/ 1) postcard_changes.post = /*post*/ ctx[1];
			postcard.$set(postcard_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(postcard.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(postcard.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(postcard, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(6:0) {#each posts as post}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*posts*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*posts*/ 1) {
				each_value = /*posts*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("PostList", slots, []);
	let { posts } = $$props;
	const writable_props = ["posts"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<PostList> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("posts" in $$props) $$invalidate(0, posts = $$props.posts);
	};

	$$self.$capture_state = () => ({ posts, PostCard });

	$$self.$inject_state = $$props => {
		if ("posts" in $$props) $$invalidate(0, posts = $$props.posts);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [posts];
}

class PostList extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { posts: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "PostList",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*posts*/ ctx[0] === undefined && !("posts" in props)) {
			console.warn("<PostList> was created without expected prop 'posts'");
		}
	}

	get posts() {
		throw new Error("<PostList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set posts(value) {
		throw new Error("<PostList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { PostList as P };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUG9zdExpc3QuZGVmZTI1NWIuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1Bvc3RDYXJkLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1Bvc3RMaXN0LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxyXG4gIGltcG9ydCB7IHNsdWdpZnkgfSBmcm9tIFwiLi4vcG9zdHMuanNcIjtcclxuICBpbXBvcnQgVGFncyBmcm9tIFwiLi4vY29tcG9uZW50cy9UYWdzLnN2ZWx0ZVwiO1xyXG4gIGV4cG9ydCBsZXQgcG9zdDtcclxuPC9zY3JpcHQ+XHJcblxyXG48ZGl2IGNsYXNzPVwicC00IG1kOnctMS8zXCI+XHJcbiAgPGRpdlxyXG4gICAgY2xhc3M9XCJ3LTIwMCBoLWF1dG8gYm9yZGVyLTIgYm9yZGVyLWdyYXktMjAwIGJvcmRlci1vcGFjaXR5LTYwIHJvdW5kZWQtbGcgb3ZlcmZsb3ctaGlkZGVuXCJcclxuICA+XHJcbiAgICA8YSBocmVmPXtgL3Bvc3RzLyR7c2x1Z2lmeShwb3N0LnRpdGxlKX1gfT5cclxuICAgICAgPGltZ1xyXG4gICAgICAgIGNsYXNzPVwidy1mdWxsIG9iamVjdC1jb3ZlciBvYmplY3QtY2VudGVyXCJcclxuICAgICAgICBzcmM9e3Bvc3QuaW1hZ2V9XHJcbiAgICAgICAgYWx0PXtwb3N0LnRpdGxlfVxyXG4gICAgICAvPlxyXG4gICAgPC9hPlxyXG4gICAgPGRpdiBjbGFzcz1cInAtNlwiPlxyXG4gICAgICA8aDJcclxuICAgICAgICBjbGFzcz1cInRyYWNraW5nLXdpZGVzdCB0ZXh0LXhzIHRpdGxlLWZvbnQgZm9udC1tZWRpdW0gdGV4dC1ncmF5LTQwMCBtYi0xXCJcclxuICAgICAgPlxyXG4gICAgICAgIDxUYWdzIHRhZ3M9e3Bvc3QudGFnc30gLz5cclxuICAgICAgPC9oMj5cclxuICAgICAgPGgxIGNsYXNzPVwidGl0bGUtZm9udCB0ZXh0LWxnIGZvbnQtbWVkaXVtIHRleHQtZ3JheS05MDAgbWItM1wiPlxyXG4gICAgICAgIHtwb3N0LnRpdGxlfVxyXG4gICAgICA8L2gxPlxyXG4gICAgICA8cCBjbGFzcz1cImxlYWRpbmctcmVsYXhlZCBtYi0zXCI+XHJcbiAgICAgICAge3Bvc3Quc3VtbWVyeSA/IHBvc3Quc3VtbWVyeSA6IFwiXCJ9XHJcbiAgICAgIDwvcD5cclxuICAgICAgPGRpdiBjbGFzcz1cImZsZXggaXRlbXMtY2VudGVyIGZsZXgtd3JhcCBcIj5cclxuICAgICAgICA8YVxyXG4gICAgICAgICAgaHJlZj17YC9wb3N0cy8ke3NsdWdpZnkocG9zdC50aXRsZSl9YH1cclxuICAgICAgICAgIGNsYXNzPVwidGV4dC1waW5rLTUwMCBpbmxpbmUtZmxleCBpdGVtcy1jZW50ZXIgbWQ6bWItMiBsZzptYi0wXCJcclxuICAgICAgICAgID5MZWFybiBNb3JlXHJcbiAgICAgICAgICA8c3ZnXHJcbiAgICAgICAgICAgIGNsYXNzPVwidy00IGgtNCBtbC0yXCJcclxuICAgICAgICAgICAgdmlld0JveD1cIjAgMCAyNCAyNFwiXHJcbiAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXHJcbiAgICAgICAgICAgIHN0cm9rZS13aWR0aD1cIjJcIlxyXG4gICAgICAgICAgICBmaWxsPVwibm9uZVwiXHJcbiAgICAgICAgICAgIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIlxyXG4gICAgICAgICAgICBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiXHJcbiAgICAgICAgICA+XHJcbiAgICAgICAgICAgIDxwYXRoIGQ9XCJNNSAxMmgxNFwiIC8+XHJcbiAgICAgICAgICAgIDxwYXRoIGQ9XCJNMTIgNWw3IDctNyA3XCIgLz5cclxuICAgICAgICAgIDwvc3ZnPlxyXG4gICAgICAgIDwvYT5cclxuICAgICAgICA8c3BhblxyXG4gICAgICAgICAgY2xhc3M9XCJ0ZXh0LWdyYXktNDAwIG1yLTMgaW5saW5lLWZsZXggaXRlbXMtY2VudGVyIGxnOm1sLWF1dG8gbWQ6bWwtMCBtbC1hdXRvIGxlYWRpbmctbm9uZSB0ZXh0LXNtIHByLTMgcHktMSBib3JkZXItci0yIGJvcmRlci1ncmF5LTIwMFwiXHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgPHN2Z1xyXG4gICAgICAgICAgICBjbGFzcz1cInctNCBoLTQgbXItMVwiXHJcbiAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXHJcbiAgICAgICAgICAgIHN0cm9rZS13aWR0aD1cIjJcIlxyXG4gICAgICAgICAgICBmaWxsPVwibm9uZVwiXHJcbiAgICAgICAgICAgIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIlxyXG4gICAgICAgICAgICBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiXHJcbiAgICAgICAgICAgIHZpZXdCb3g9XCIwIDAgMjQgMjRcIlxyXG4gICAgICAgICAgPlxyXG4gICAgICAgICAgICA8cGF0aCBkPVwiTTEgMTJzNC04IDExLTggMTEgOCAxMSA4LTQgOC0xMSA4LTExLTgtMTEtOHpcIiAvPlxyXG4gICAgICAgICAgICA8Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjEyXCIgcj1cIjNcIiAvPlxyXG4gICAgICAgICAgPC9zdmc+MS4yS1xyXG4gICAgICAgIDwvc3Bhbj5cclxuICAgICAgICA8c3BhblxyXG4gICAgICAgICAgY2xhc3M9XCJ0ZXh0LWdyYXktNDAwIGlubGluZS1mbGV4IGl0ZW1zLWNlbnRlciBsZWFkaW5nLW5vbmUgdGV4dC1zbVwiXHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgPHN2Z1xyXG4gICAgICAgICAgICBjbGFzcz1cInctNCBoLTQgbXItMVwiXHJcbiAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXHJcbiAgICAgICAgICAgIHN0cm9rZS13aWR0aD1cIjJcIlxyXG4gICAgICAgICAgICBmaWxsPVwibm9uZVwiXHJcbiAgICAgICAgICAgIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIlxyXG4gICAgICAgICAgICBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiXHJcbiAgICAgICAgICAgIHZpZXdCb3g9XCIwIDAgMjQgMjRcIlxyXG4gICAgICAgICAgPlxyXG4gICAgICAgICAgICA8cGF0aFxyXG4gICAgICAgICAgICAgIGQ9XCJNMjEgMTEuNWE4LjM4IDguMzggMCAwMS0uOSAzLjggOC41IDguNSAwIDAxLTcuNiA0LjcgOC4zOCA4LjM4IDAgMDEtMy44LS45TDMgMjFsMS45LTUuN2E4LjM4IDguMzggMCAwMS0uOS0zLjggOC41IDguNSAwIDAxNC43LTcuNiA4LjM4IDguMzggMCAwMTMuOC0uOWguNWE4LjQ4IDguNDggMCAwMTggOHYuNXpcIlxyXG4gICAgICAgICAgICAvPlxyXG4gICAgICAgICAgPC9zdmc+NlxyXG4gICAgICAgIDwvc3Bhbj5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICA8L2Rpdj5cclxuPC9kaXY+XHJcbiIsIjxzY3JpcHQ+XHJcbiAgZXhwb3J0IGxldCBwb3N0cztcclxuICBpbXBvcnQgUG9zdENhcmQgZnJvbSBcIi4uL2NvbXBvbmVudHMvUG9zdENhcmQuc3ZlbHRlXCI7XHJcbjwvc2NyaXB0PlxyXG5cclxueyNlYWNoIHBvc3RzIGFzIHBvc3R9XHJcbiAgPFBvc3RDYXJkIHtwb3N0fSAvPlxyXG57L2VhY2h9XHJcblxyXG48IS0tIDxzZWN0aW9uIGNsYXNzPVwidGV4dC1ncmF5LTYwMCBib2R5LWZvbnRcIj5cclxuICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyIHB4LTUgcHktMjQgbXgtYXV0b1wiPlxyXG4gICAgPGRpdiBjbGFzcz1cImZsZXggZmxleC13cmFwIC1tLTRcIj5cclxuICAgICAgeyNlYWNoIHBvc3RzIGFzIHBvc3R9XHJcbiAgICAgICAgPFBvc3RDYXJkIHtwb3N0fSAvPlxyXG4gICAgICB7L2VhY2h9XHJcbiAgICA8L2Rpdj5cclxuICA8L2Rpdj5cclxuPC9zZWN0aW9uPlxyXG4gLS0+XHJcbjwhLS0gPGEgaHJlZj17YC9wb3N0cy8ke3NsdWdpZnkocG9zdC50aXRsZSl9YH0+XHJcbiAgICAgICAgICAgIDxpbWcgc3JjPXtwb3N0LmltYWdlfSBhbHQ9e3Bvc3QudGl0bGV9IHdpZHRoPVwiMjAwXCIgaGVpZ2h0PVwiYXV0b1wiIC8+XHJcbiAgICAgICAgICAgIDxoMj57cG9zdC50aXRsZX08L2gyPlxyXG4gICAgICAgICAgICA8cD57cG9zdC5zdW1tYXJ5fTwvcD5cclxuICAgICAgICAgIDwvYT4gLS0+XHJcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5QkF3QlMsR0FBSSxJQUFDLEtBQUs7Ozs7MEJBR1YsR0FBSSxJQUFDLE9BQU8sWUFBRyxHQUFJLElBQUMsT0FBTyxHQUFHLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyQkFOckIsR0FBSSxJQUFDLElBQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZDQVJoQixHQUFJLElBQUMsS0FBSztpREFDVixHQUFJLElBQUMsS0FBSzs7a0RBSkEsT0FBTyxVQUFDLEdBQUksSUFBQyxLQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrREFxQmYsT0FBTyxVQUFDLEdBQUksSUFBQyxLQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OytFQWxCL0IsR0FBSSxJQUFDLEtBQUs7Ozs7cUZBQ1YsR0FBSSxJQUFDLEtBQUs7Ozs7c0ZBSkEsT0FBTyxVQUFDLEdBQUksSUFBQyxLQUFLOzs7Ozt3REFXckIsR0FBSSxJQUFDLElBQUk7OzZFQUdwQixHQUFJLElBQUMsS0FBSzs4RUFHVixHQUFJLElBQUMsT0FBTyxZQUFHLEdBQUksSUFBQyxPQUFPLEdBQUcsRUFBRTs7c0ZBSWYsT0FBTyxVQUFDLEdBQUksSUFBQyxLQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0E1Qi9CLElBQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NEJDRVYsR0FBSzs7OztnQ0FBVixNQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MkJBQUMsR0FBSzs7OzsrQkFBVixNQUFJOzs7Ozs7Ozs7Ozs7Ozs7O3dCQUFKLE1BQUk7Ozs7Ozs7Ozs7a0NBQUosTUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FKTyxLQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OyJ9
